# 정규화

## 정규화란?
- 모델링 시 최대한 중복 데이터를 허용하지 않아야 저장공간의 효율적 사용과 업무 프로세스의 성능을 기대할 수 있다.
- 이러한 중복 데이터를 허용하지 않는 방식으로 데이터를 설계하는 방식


<p>

## 정규화(DB Normalization)의 개념
- 하나의 엔티티에 많은 속성을 넣게 되면, 해당 엔티티를 조회할 때마다 많은 양의 데이터가 조회될 것이므로  
  최소한의 데이터만을 하나의 `엔티티`에 넣는 식으로 데이터를 `분해하는 과정`을 정규화라고 한다.
- 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 과정이라고 볼 수 있다.
- 데이터의 중복을 제거하고 데이터 모델의 독립성을 확보
- 데이터의 `이상현상을 줄이기 위한` 데이터베이스 설계 기법
- 엔티티를 상세화하는 과정으로 `논리 데이터 모델링 수행 시점`에서 고려됨
- 제 1정규화부터 제 5정규화까지 존재, 실질적으로는 `제 3정규화`까지만 수행

</p>

<p>

## 이상현상(Abnormality)
- 정규화를 하지 않아서 발생하는 현상(삽입 이상, 갱신 이상, 삭제 이상)
- 특정 인스턴스가 삽입될 때 정의되지 않아도 될 속성까지도 반드시 입력되어야 하는(`삽입 이상`) 현상이 발생한다.
- ex) 만약 사원 + 부서 엔티티를 합쳐 놓고 사원번호, 사원이름, 전화번호, 부서번호, 부서명, 부서위치의 속성이 존재할 때
  새로운 사원 값이 추가될 때 정해지지 않은 부서정보(부서번호, 부서명, 부서위치) 모두 임의값 또는 NULL이 삽입되어야한다.
  반대로 부서가 새로 추가될 경우 소속 사원이 없어도 사원과 관련된 속성이 불필요하게 값이 입력되어야한다.
- 불필요한 값까지 입력되어야 하는 현상을 `삽입 이상`, 그 외의 갱신이상, 삭제 이상이 발생할 수 있다.
- ex) 부서 정보만 삭제하면 되는데 관련된 사원정보도 함께 삭제되는 현상(`삭제이상`)
</p>

<p>

## 정규화 단계
### 1. 제 1정규화(1NF)
- 테이블의 컬럼이 `원자성`(한 속성이 한 개의 값만 갖는 특성)을 갖도록 테이블을 분해하는 단계
- 쉽게 말해 하나의 행과 컬럼이 반드시 하나의 값만 입력되도록 행을 분리하는 단계(`중복 속성에 다한 분리`)
- ex) 구매 테이블의 제 1정규화 -> 상품이 여러 개의 값이 있으므로 여러 인스턴스로 분리

>정규화 이전

| 이름  | 구매상품  |             
|-----|-------|             
| 홍길동 | 샴푸,린스 |             
| 김길동 | 우유,치즈 |             
| 최길동 | 세제    |             

>정규화 이후

| 이름  | 구매상품  |
|-----|-------|
| 홍길동 | 샴푸 |
| 홍길동 | 린스 |
| 김길동 | 치즈 |
| 김길동 | 치즈 |
| 최길동 | 세제 |


### 2. 제 2정규화(2NF)
- 제 1정규화는 진행한 테이블에 대한 `완전 함수 종속`을 만들도록 테이블을 분해
- `완전 함수 종속`이란, 기본키를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정짓는 형태
- 기본키의 부분 집합이 다른 컬럼과 1:1 대응 관계를 갖지 않는 상태를 의미
- 즉, PK(Primary Key)가 2개 이상일 때 발생하며, PK의 일부와 종속되는 관계가 있다면 분리
- ex) 수강 이력 테이블의 제 2정규화
  - 기본키(학생 번호 + 강의명) 중, 강의명에 의해 강의실 결정 -> 완전 함수 종속성 위배(부분함수 종속성을 가짐)
  - PK와 부분 함수 종속성을 갖는 컬럼을 각각 다른 테이블로 분해

>정규화 이전

| 학생번호 | 강의명   | 강의실 | 성적 |             
|------|-------|  ------|-------|            
| 1000 | 컴퓨터공학 |  자연관 | A   |        
| 1001 | 컴퓨터공학    | 자연관 | B|     

>정규화 이후

| 학생번호 | 강의명    | 성적 |             
|------|-------|  ------|            
| 1000 | 컴퓨터공학 |   A   |        
| 1001 | 컴퓨터공학   |  B|     

| 강의명   | 강의실 |            
|------|-------|   
| 컴퓨터공학 |  자연관 |   
| 컴퓨터공학    | 자연관 |

</p>

<p>

### 제 3정규화(3NF)
- 제 2정규화를 진행한 테이블에 `이행적 종속`을 없애도록 테이블 분리
- 이행적 종속성이란, `A -> B`, `B -> C`와 같은 관계를 성립할 때 `A -> C`가 성립되는 것을 말함.
- (A,B)와 (B,C)로 분리하는 것이 제 3정규화이다.
- ex) 구매 테이블의 제 3정규화
  - 고객 번호에 의해 상품명이 결정, 상품명에 의해 가격이 결정되는데 고객번호에 의해서도 구매가격이 결정됨
  - 고객이 상품을 결정하면 그에 매칭되는 가격이 결정되는 구조이므로 따라서 (고객번호+상품명)과 (상품명+가격)으로 분리하는 것

>정규화 이전

| 고객번호 | 상품명 | 가격   |              
|------|-----|------|            
| 1000 | 우유  | 2000 |         
| 1001 | 치즈  | 3000 | 

>정규화 이후

| 고객번호 | 상품명 |         
|------|-----|   
| 1000 | 우유  |      
| 1001 | 치즈  | 

| 상품명 | 가격   |              
|----|------|            
|우유  | 2000 |         
|치즈  | 3000 | 

**결정자와 종속 관계**
- 만약 A 속성이 B 속성의 값을 결정하게 된다면, 이 때 A는 B의 결정자라고 하며, B는 A에 종속된다고 표현한다.
- 즉, 고객번호가 상품명의 결정자이며, 상품명 역시 가격의 결정자이다.

### BCNF(Boyce-Codd Normal Form) 정규화
- 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
- 결정자가 후보키가 아닌 다른 컬럼에 종속되면 안됨

### 제 4정규화
- 여러 컬럼들이 하나의 컬럼을 종속시키는 경우 분해하여 다중값 종속성 제거

### 제 5정규화
- 조인에 의해서 종속성이 발생되는 경우 분해


</p>

<p>

## 반정규화 = 역정규화(De-Normalization)의 개념
- 데이터베이스의 성능 향상을 위해 데이터 `중복을 허용`하고 조인을 줄이는 데이터베이스 성능 향상 비법
- 시스템의 성능 향상, 개발 및 운영의 단순화를 위해 정규화된 데이터 모델을 중복, 통합, 분리하는 데이터 모델링 기법
- 조회(Select) 속도를 향상시키지만, 데이터 모델의 유연성이 낮아짐
- `데이터 무결성 유지` 유의해야한다.
> 비정규화는 정규화를 수행하지 않음을 의미한다.

## 반정규화 수행 케이스
### 1. 반정규화 대상조사
  - 정규화에 충실하여 종속성, 활용성은 향상되지만 `수행 속도가 느려지는 경우`
  - `다량의 범위를 자주 처리`해야하는 경우
  - `특정 범위의 데이터만 자주 처리`하는 경우
  - `요약, 집계 정보가 자주 요구`되는 경우
### 2. 다른 방법 유도 검토
  1. VIEW 사용
     - 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 사용한다.
     - VIEW가 성능을 향상 X
  2. 클러스터링
     - 대량의 데이터 처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정한다.
     - 조회가 대부분일 때 클러스터링 적용
  3. 파티셔닝(PK로 테이블 분리)
     - 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다.
     - 파티셔닝 키에 의해 물리적 저장공간 분리
     - `데이터 액세스 성능을 향상`시키기 위해 사용
  4. 캐시
     - 응용 어플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.
</p>

<p>

## 반정규화 적용
### 1. 테이블 반정규화
1. 테이블 병합(1:1관계, 1:M관계, 슈퍼/서브타입)
    - 1:1 관계를 통합하여 성능향상
    - 1:M 관계를 통합하여 성능향상
    - 슈퍼/서브 관계를 통합하여 성능향상
        - 슈퍼: 공통부분, 서브: 공통으로부터 상속받아 다른 엔티티와 차이나는 속성
2. 테이블 분할(수직분할, 수평분할)
    - 수직분할 : `칼럼`단위로 테이블을 디스크 I/O로 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상
    - 수평분할 : `로우`단위로 집중되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능 향상
3. 테이블 추가
    - 중복 : 다른 업무이거나 `서버가 다른 경우` 동일한 테이블 구조를 중복하여 원격조인을 제거하여 성능 향상
    - 통계 : SUM, AVG 등을 미리 수행하여 계산해둠으로써 조회 시 성능을 향상
    - 이력 : 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
    - 부분 : 하나의 테이블의 전체 칼럼 중 `자주 이용하는 집중화된 컬럼들이 있을 때` 디스크 I/O를 줄이기 위해
      해당 컬럼들을 모아놓은 별도의 반정규화된 테이블을 생성 => `부분 테이블 추가`

### 2. 컬럼 반정규화
1. 중복컬럼 추가
   - 조인에 의해 성능저하를 예방하기 위해 `중복된 컬럼을 위치` 시킨다.
2. 파생컬럼 추가
   - 트랜잭션이 처리되는 시점에 `계산`에 의해 발생되는 성능저하를 예방하기 위해 `미리 값을 계산`하여 컬럼에 보관
3. 이력테이블 컬럼 추가
   - 대량 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해
     이력테이블에 `기능성 컬럼`(최근값 여부, 시작과 종료일자 등)을 추가한다.
4. 응용시스템 오작동을 위한 컬럼 추가
   - 업무적으로 의미가 없지만 사용자의 실수로 원래 값으로 복구하기를 원하는 경우
     `이전 데이터를 임시적으로 중복하여 보관`하는 기법
5. `PK`에 의한 컬럼 추가
   - 단일 PK 안에서 특정 값을 별도로 조회하는 경우 성능 저하가 발생할 수 있어 `일반속성`으로 추가한다.

### 3. 관계 반정규화
- **중복관계 추가**
  - 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이대 발생할 수 있는 성능저하를 예방하기 위해 `추가적인 관계`를 맺는 방법
  1. 로우 체이닝
     - 로우의 길이가 너무 길어서 데이터블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
     - 1:1로 테이블 분리하여 조회 성능 향상
  2. 로우 마이그레이션
     - 데이터블록에서 수정이 발생하면 수정된 데이터를 해당 데이터블록에 저장하지 못하고 다른 블록의 빈 공간에 저장하는 방식 

- **PK에 의해 테이블을 분할(물리적 분리)하는 방법(`파티셔닝`)** 
  1. RANGE PARTITION
     - 대상 테이블이 날짜 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리되는 경우
     - ex) 요금_0401
  2. LIST PARTITION
     - 지점, 사업소 등 핵심적인 코드값으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블의 경우
     - ex) 고객_서울
  3. HASH PARTITION
     - 지정된 HASH 조건에 따라 해시 알고리즘이 적용되어 테이블 분리
> 1개 테이블에 많은 데이터가 저장되었을 때,    
> 논리적으로 1개 테이블이지만 물리적으로는 여러 테이블로 분리


- **테이블에 대한 수평/수직분할의 절차**
  1. 데이터 모델링을 완성한다.
  2. DB 용량 산정한다.
  3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석
  4. 컬럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는 지 분석하여
     집중화된 단위로 테이블을 분리하는 것을 검토한다.
     - 컬럼이 많다 -> 1:1 분리
     - 데이터가 많다 -> 파티셔닝

- **슈퍼/서브 타입 모델**
  - 업무를 구성하는 데이터를 공통과 차이점의 특징을 고려하여 효과적으로 표현, 논리적 모델
  - 슈퍼 타입 : `공통 부분`
  - 서브 타입 : 공통으로부터 상속받아 다른 엔터티와 `차이가 있는 부분`

- **슈퍼/서브 타입 데이터 모델의 변환기술**
  1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성(OneToOne Type)
  2. 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 `슈퍼+서브타입 테이블`로 구성(Plus Type)
  3. `전체를 하나로 묶어 트랜잭션이 발생할 때`는 하나의 테이블로 구성(Single Type, All in One Type)

- **인덱스 특성을 고려한 PK/FK DB 향상**
  - 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 효율을 나타낸다.
  - 앞쪽에 위치한 속성값이 가급적 `=` 아니면 최소한 범위 `BETWEEN`, `<>`가 들어와야 효율적이다.
</p>